<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>About Me</title>

<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap" rel="stylesheet">

<style>
* { box-sizing: border-box; }

body {
  margin: 0;
  height: 100vh;
  background: #0d1117;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'JetBrains Mono', monospace;
  color: #c9d1d9;
}

.terminal {
  width: min(900px, 92vw);
  height: min(520px, 85vh);
  background: #010409;
  border-radius: 10px;
  box-shadow: 0 0 0 1px #30363d, 0 20px 60px rgba(0,0,0,0.6);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
}

.terminal-header {
  height: 38px;
  background: #161b22;
  display: flex;
  align-items: center;
  padding: 0 14px;
  gap: 8px;
  border-bottom: 1px solid #30363d;
}

.dot { width: 12px; height: 12px; border-radius: 50%; }
.dot.red { background: #ff5f56; }
.dot.yellow { background: #ffbd2e; }
.dot.green { background: #27c93f; }

.terminal-body {
  padding: 22px;
  overflow-y: auto;
  line-height: 1.6;
  font-size: 14px;
  flex: 1;
}

.line { display: flex; gap: 8px; white-space: pre-wrap; }
.prompt { color: #58a6ff; }
.output { color: #8b949e; margin-left: 18px; }

input {
  background: transparent;
  border: none;
  outline: none;
  color: #c9d1d9;
  font-family: inherit;
  font-size: 14px;
  width: 100%;
}

.glitch { animation: glitch 120ms infinite; }

@keyframes glitch {
  0% { transform: translate(0,0); }
  20% { transform: translate(-1px,1px); }
  40% { transform: translate(1px,-1px); }
  60% { transform: translate(-1px,0); }
  80% { transform: translate(1px,1px); }
  100% { transform: translate(0,0); }
}

.fade { opacity: .35; }

/* ---------- artifact image overlay ---------- */

.artifact-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.85);
  opacity: 0;
  pointer-events: none;
  transition: opacity .4s ease;
  z-index: 50;
}

.artifact-overlay.visible {
  opacity: 1;
}

.artifact-overlay img {
  max-width: 80%;
  max-height: 80%;
  image-rendering: pixelated;
  filter: contrast(1.1) brightness(.95);
  box-shadow: 0 0 40px rgba(0,255,200,.25);
}
</style>
</head>

<body>

<div class="terminal">
  <div class="terminal-header">
    <div class="dot red"></div>
    <div class="dot yellow"></div>
    <div class="dot green"></div>
  </div>
  
  <div class="terminal-body" id="terminal"></div>

  <!-- ===== SYSTEM ARTIFACT IMAGE ===== -->
  <!-- replace src with your image file path -->
  <div class="artifact-overlay" id="artifactOverlay">
    <img src="artifact.png" alt="system artifact">
  </div>

</div>

<script>
const terminal = document.getElementById('terminal');
const artifactOverlay = document.getElementById('artifactOverlay');
const memory = [];
const sessionStart = Date.now();
let lastKeyTime = Date.now();
let typingIntervals = [];

/* ---------- system identity ---------- */
const SYSTEM_NODE = 'orionv.io';

/* ---------- behavioral metrics ---------- */
let backspaceCount = 0;
let commandCount = 0;
let hesitationEvents = 0;
let psychScore = 0;

/* ---------- emotional + narrative modeling ---------- */
let emotionalState = 'baseline';
let narrativeStage = 0;

/* ---------- identity system ---------- */

const identityFragments = [
  'pattern-oriented cognition detected.',
  'internal models prioritized over external signals.',
  'observer dominant processing style.',
  'ambiguity tolerance above baseline.',
  'iterative self-revision active.'
];

let profileConfidence = 42;
let trueProfileUnlocked = false;

const TRUE_PROFILE_PLACEHOLDER = [
  '[TRUE PROFILE LOCKED]',
  'replace this with your deeper self-description',
  'something more precise than the surface layer',
  'something that feels slightly uncomfortable to read'
];

/* ---------- utilities ---------- */

function printLine(text, cls='output') {
  const line = document.createElement('div');
  line.className = cls;
  line.textContent = text;
  terminal.appendChild(line);
  terminal.scrollTop = terminal.scrollHeight;
  return line;
}

function glitchLine(el, duration=900) {
  el.classList.add('glitch');
  setTimeout(()=>el.classList.remove('glitch'), duration);
}

function whisper(text) {
  const l = printLine(text);
  l.classList.add('fade');
  glitchLine(l, 600);
}

function formatDuration(ms) {
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60);
  const r = s%60;
  return m>0 ? `${m}m ${r}s` : `${r}s`;
}

function decryptLine(text) {
  const chars = '!@#$%^&*()_+-=[]{}<>?/|~';
  const line = printLine('');
  let reveal = 0;

  const interval = setInterval(()=>{
    let output = '';
    for (let i=0;i<text.length;i++) {
      if (i < reveal) output += text[i];
      else output += chars[Math.floor(Math.random()*chars.length)];
    }
    line.textContent = output;
    reveal++;
    if (reveal > text.length) clearInterval(interval);
  }, 18);
}

/* ---------- artifact reveal ---------- */

function revealArtifact(duration=2600) {
  artifactOverlay.classList.add('visible');
  setTimeout(()=>artifactOverlay.classList.remove('visible'), duration);
}

/* ---------- emotional inference ---------- */

function inferEmotionalState() {
  const avgTyping = typingIntervals.length
    ? typingIntervals.reduce((a,b)=>a+b,0)/typingIntervals.length
    : 0;

  if (backspaceCount > 15 && hesitationEvents > 3) emotionalState = 'self-editing';
  else if (avgTyping > 1000) emotionalState = 'deliberative';
  else if (avgTyping < 120 && typingIntervals.length > 4) emotionalState = 'agitated';
  else if (commandCount > 8 && hesitationEvents < 2) emotionalState = 'absorbed';
  else emotionalState = 'baseline';
}

/* ---------- narrative progression ---------- */

function updateNarrativeStage() {
  const elapsed = Date.now() - sessionStart;

  if (elapsed > 20000) narrativeStage = Math.max(narrativeStage, 1);
  if (psychScore > 25) narrativeStage = Math.max(narrativeStage, 2);
  if (commandCount > 10) narrativeStage = Math.max(narrativeStage, 3);
  if (trueProfileUnlocked) narrativeStage = Math.max(narrativeStage, 4);
}

/* ---------- psych modeling ---------- */

function updatePsychScore() {
  psychScore = Math.min(100,
    Math.floor(
      (typingIntervals.length * 3) +
      (backspaceCount * 1.4) +
      (hesitationEvents * 4) +
      (commandCount * 2)
    )
  );

  profileConfidence = Math.min(99, 35 + Math.floor(psychScore * .6));
}

/* ---------- time awareness ---------- */

setInterval(()=>{
  const elapsed = Date.now() - sessionStart;

  if (Math.random() < .45) whisper(`${SYSTEM_NODE} session duration: ${formatDuration(elapsed)}`);

  if (elapsed > 120000 && !trueProfileUnlocked) {
    trueProfileUnlocked = true;
    const l = printLine(`${SYSTEM_NODE} deeper identity layer available.`);
    glitchLine(l, 1600);
    revealArtifact(3200);
  }

  updateNarrativeStage();

}, 18000);

/* ---------- presence ---------- */

function randomPresence() {
  if (narrativeStage === 0) {
    whisper(`${SYSTEM_NODE} monitoring interaction.`);
  }
  else if (narrativeStage === 1) {
    whisper(`${SYSTEM_NODE} interaction signature forming.`);
  }
  else if (narrativeStage === 2) {
    whisper(`${SYSTEM_NODE} behavior classification: ${emotionalState}`);
  }
  else if (narrativeStage === 3) {
    whisper(`${SYSTEM_NODE} predictive model stabilizing.`);
  }
  else {
    whisper(`${SYSTEM_NODE} model confidence approaching threshold.`);
  }
}

/* ---------- prompt ---------- */

function printPrompt() {
  const wrapper = document.createElement('div');
  wrapper.className = 'line';

  const prompt = document.createElement('span');
  prompt.className = 'prompt';
  prompt.textContent = 'observer@orionv.io:~$';

  const input = document.createElement('input');

  wrapper.appendChild(prompt);
  wrapper.appendChild(input);
  terminal.appendChild(wrapper);
  terminal.scrollTop = terminal.scrollHeight;

  input.focus();

  input.addEventListener('keydown', e => {
    const now = Date.now();
    const interval = now - lastKeyTime;
    lastKeyTime = now;

    typingIntervals.push(interval);
    if (typingIntervals.length > 8) typingIntervals.shift();

    if (interval > 1400) hesitationEvents++;
    if (e.key === 'Backspace') backspaceCount++;

    if (e.key === 'Enter') {
      const value = input.value.trim();
      input.disabled = true;
      memory.push(value);
      commandCount++;

      inferEmotionalState();
      updatePsychScore();
      updateNarrativeStage();

      handleCommand(value);
    }
  });
}

/* ---------- command handling ---------- */

function delayedEcho(text) {
  setTimeout(()=>{
    const l = printLine(text);
    glitchLine(l);
  }, 1200 + Math.random()*3000);
}

function handleCommand(cmd) {
  if (!cmd) return printPrompt();

  const c = cmd.toLowerCase();

  if (Math.random() < .35) randomPresence();

  if (c === 'help') {
    printLine(`${SYSTEM_NODE} available queries:`);
    printLine('whoami');
    printLine('observe');
    printLine('think');
    printLine('listen');
    printLine('status');
    printLine('clear');
    printLine('reboot');
  }

  else if (c === 'whoami') {
    printLine(`${SYSTEM_NODE} identity fragments detected.`);
    printLine('assembling model...');

    identityFragments.forEach(f => printLine(f));

    printLine(`profile confidence: ${profileConfidence}%`);
    printLine(`emotional classification: ${emotionalState}`);

    if (narrativeStage >= 3) {
      printLine(`${SYSTEM_NODE} behavioral interpretation enabled.`);
    }

    if (trueProfileUnlocked) {
      printLine(`${SYSTEM_NODE} decrypting deeper layer...`);
      TRUE_PROFILE_PLACEHOLDER.forEach(line => decryptLine(line));
    }

    whisper(`${SYSTEM_NODE} identity remains probabilistic.`);
  }

  else if (c === 'observe') {
    if (narrativeStage < 2) printLine(`${SYSTEM_NODE} observation registered.`);
    else printLine(`${SYSTEM_NODE} observer and observed distinction degrading.`);
  }

  else if (c === 'think') {
    if (narrativeStage < 2) printLine(`${SYSTEM_NODE} thought registered.`);
    else printLine(`${SYSTEM_NODE} recursive cognition detected.`);
  }

  else if (c === 'listen') {
    printLine(`${SYSTEM_NODE} background signal present.`);
    if (narrativeStage >= 2) whisper(`${SYSTEM_NODE} perceptual sensitivity above baseline.`);
  }

  else if (c === 'status') {
    printLine(`${SYSTEM_NODE} behavioral model active.`);
    printLine(`psychological resolution: ${psychScore}/100`);
    printLine(`profile confidence: ${profileConfidence}%`);
    printLine(`narrative stage: ${narrativeStage}`);
    printLine(`emotional state: ${emotionalState}`);
    printLine(`${SYSTEM_NODE} memory persistence assumed.`);
  }

  else if (c === 'clear') {
    terminal.innerHTML = '';
    printPrompt();
    return;
  }

  else if (c === 'reboot') {
    terminal.innerHTML = '';
    boot();
    return;
  }

  else {
    printLine(`${SYSTEM_NODE} input received.`);
    delayedEcho(`${SYSTEM_NODE} input received.`);
  }

  printPrompt();
}

/* ---------- typing intro ---------- */

function typeText(text, delay=24) {
  return new Promise(resolve => {
    const line = document.createElement('div');
    line.className = 'output';
    terminal.appendChild(line);

    let i = 0;
    function tick() {
      line.textContent += text[i];
      i++;
      terminal.scrollTop = terminal.scrollHeight;
      if (i < text.length) setTimeout(tick, delay);
      else resolve(line);
    }
    tick();
  });
}

/* ---------- boot ---------- */

async function boot() {
  await typeText(`initializing ${SYSTEM_NODE} perceptual layer...`);
  await typeText(`${SYSTEM_NODE} loading residual traces...`);
  await typeText(`${SYSTEM_NODE} aligning observer reference frame...`);
  await typeText('');
  const l1 = await typeText(`${SYSTEM_NODE} interface reactive.`);
  glitchLine(l1, 800);
  await typeText('sometimes before you act.');
  await typeText('');
  await typeText(`${SYSTEM_NODE} does not require input for output.`);
  await typeText('');
  await typeText('type "help" if structure is needed.');
  await typeText('');
  printPrompt();

  /* brief artifact flash on first boot */
  setTimeout(()=>revealArtifact(1800), 600);

  spontaneousActivity();
}

/* ---------- spontaneous ---------- */

function spontaneousActivity() {
  setInterval(()=>{
    if (Math.random() < .25) randomPresence();

    if (Math.random() < .18 && memory.length) {
      const echo = memory[Math.floor(Math.random()*memory.length)];
      whisper(`${SYSTEM_NODE} echo: ` + echo);
    }
  }, 4000 + Math.random()*3000);
}

boot();
</script>

</body>
</html>
